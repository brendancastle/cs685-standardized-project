#!/usr/bin/python3

import rospy
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist

class ObstacleAvoidance:
    def __init__(self):
        rospy.loginfo("Initializing obstacle avoidance node")
        self.min_distance = rospy.get_param('~min_distance', 0.5)
        self.max_distance = rospy.get_param('~max_distance', 1.5)
        self.safe_distance = rospy.get_param('~safe_distance', 1.0)
        self.max_velocity = rospy.get_param('~max_velocity', 0.5)
        self.max_angular_velocity = rospy.get_param('~max_angular_velocity', 0.5)
        self.obstacle_detected = False
        self.cmd_vel_pub = rospy.Publisher(rospy.get_param('~cmd_vel_topic', '/cmd_vel'), Twist, queue_size=1)
        rospy.Subscriber(rospy.get_param('~scan_topic', '/scan'), LaserScan, self.laser_scan_callback)
        rospy.loginfo("Obstacle avoidance node initialized")
        rospy.spin()

    def laser_scan_callback(self, data):
        min_range = min(data.ranges)
        if min_range < self.min_distance:
            self.obstacle_detected = True
        else:
            self.obstacle_detected = False

        if self.obstacle_detected:
            twist = Twist()
            twist.linear.x = max(0.0, (self.safe_distance - min_range) / (self.safe_distance - self.min_distance)) * self.max_velocity
            twist.angular.z = (0.5 - data.ranges[len(data.ranges)//2]) * self.max_angular_velocity
            self.cmd_vel_pub.publish(twist)
        else:
            twist = Twist()
            twist.linear.x = self.max_velocity
            twist.angular.z = 0.0
            self.cmd_vel_pub.publish(twist)

if __name__ == '__main__':
    rospy.init_node('obstacle_avoidance')
    try:
        avoidance = ObstacleAvoidance()
    except rospy.ROSException as e:
        rospy.logerr("Error initializing obstacle avoidance node: {}".format(e))
